{"version":3,"sources":["verifyToken.js"],"names":["jwt","require","module","exports","req","res","next","header","console","token","status","send","verified","verify","process","env","TOKEN_SECRET","user","error"],"mappings":"aAAA,IAAMA,IAAMC,QAAQ,gBAKpBC,OAAOC,QAAU,SAASC,EAAKC,EAAKC,GAApCJ,IAAOC,EAAPC,EAAiBG,OAASH,iBAExBI,GADAA,QAAMC,IAAQL,IACdI,EAAA,OAAAH,EAAAK,OAAA,KAAAC,KAAA,iBAGA,IACG,IAAAC,EAAAZ,IAAAa,OAAAJ,EAAAK,QAAAC,IAAAC,cAGDZ,EAAIa,KAAOL,EAAXR,IAEA,MAAOc,GADPZ,EAAII,OAAA,KAAAC,KAAA","file":"verifyToken.min.js","sourcesContent":["const jwt = require('jsonwebtoken');\n\n//Creating a middlweare function to check if user has that token before they can access a page\n//so every private route will have this middleware function\n\nmodule.exports = function(req, res, next) {\n  const token = req.header('Authorization');\n  console.log(token)\n  if(!token) return res.status(401).send ('Access denied');\n\n  try {\n     //set the variable to have the jwt.verify(token, secret)\n     const verified = jwt.verify(token, process.env.TOKEN_SECRET)\n    //the verify brings the payload that has the id and dateofcreation \n    req.user = verified; //we now have access to the req.user\n    next()\n  } catch (error) {\n    res.status(400).send('Invalid Token')\n  }\n\n\n}\n\n\n"]}