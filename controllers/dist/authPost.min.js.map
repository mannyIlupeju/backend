{"version":3,"sources":["authPost.js"],"names":["User","require","bcrypt","registerValidation","loginValidation","isError","valid","registerPost","req","res","_registerValidation","error","salt","hashedPassword","user","regeneratorRuntime","async","_context","prev","next","body","abrupt","status","message","awrap","findOne","email","sent","send","hash","password","name","save","t0","stop","_loginValidation","token","_context2","details","emailExist","compare","jwt","sign","_id","process","env","TOKEN_SECRET","module","exports","loginPost"],"mappings":"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","file":"authPost.min.js","sourcesContent":["\nconst User = require('../models/auth')\nconst jwt = require('jsonwebtoken') //for login verification\nconst bcrypt = require('bcryptjs') //we use this to protect the password \nconst {registerValidation, loginValidation} = require('../validation')\nconst { isError, valid } = require('joi')\n\n\nconst registerPost = async (req,res)=>{\n  //Validate data before we add a user \n  const {error} = registerValidation(req.body)\n  if(error) return res.status(400).send(error.details[0].message)\n\n  //check if user is in database\n  const emailExist = await User.findOne({email: req.body.email})\n  if (emailExist) res.status(400).send('Email already exists')\n\n  //Hash the password - We must protect password from being visible when we save it\n  const salt = await bcrypt.genSalt(10) //the complexity of the string that will get generated to protect our password\n  const hashedPassword = await bcrypt.hash(req.body.password, salt)\n\n  \n  // To Create a new user\n  const user = new User({\n    name: req.body.name,\n    email: req.body.email,\n    password: hashedPassword\n  });\n\n  try {\n    const savedUser = await user.save()\n    \n  } catch(err) {\n    res.status(400).send(err)\n  }\n}\n\n\nconst loginPost = async (req,res)=>{\n   const {error} = loginValidation(req.body)\n   if(error) return res.status(400).send(error.details[0].message)\n\n   //CHECK IF USER EXISTS\n   const user = await User.findOne({email: req.body.email})\n   if(!user) return res.status(400).send(\"Email is not found\") \n   \n   \n\n   //CHECK IF PASSWORD IS CORRECT\n   const validPass = await bcrypt.compare(req.body.password, user.password) \n   if(!validPass) return res.status(400).send('Login failed')\n\n   \n  //Create and assign a token\n  //it takes the ID to know the user is logged in and a secret token\n  const token = jwt.sign({_id: user._id}, process.env.TOKEN_SECRET); \n  res.header('Authorization', token).send({token})\n\n}\n\n\n\n\n\nmodule.exports = {registerPost, loginPost}"]}