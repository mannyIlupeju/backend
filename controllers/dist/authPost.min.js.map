{"version":3,"sources":["authPost.js"],"names":["User","require","bcrypt","registerValidation","loginValidation","req","res","_registerValidation","error","salt","hashedPassword","user","regeneratorRuntime","async","_context","prev","next","body","abrupt","status","send","details","message","awrap","findOne","email","sent","genSalt","hash","password","name","save","t0","stop","loginPost","_loginValidation","token","_context2","compare","sign","header","module","exports","registerPost"],"mappings":"aACA,IAAMA,KAAOC,QAAQ,kBAAfD,IAAOC,QAAQ,gBAEfC,OAASD,QAAQ,qBADaA,QAAA,iBAA3BE,4BAAAA,mBAAWC,yBAAAA,gBACdF,aAAiB,SAAAG,EAAvBC,GAAuB,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAE,MAAA,KAAA,EAAA,GAAAT,EAMLJ,mBAAmBE,EAAIY,MAAhCT,EANcD,EAMdC,MANc,OAAAM,EAAAI,OAAA,SACuBjB,EAAQkB,OAAA,KAAAC,KAMdZ,EAAMa,QAAQ,GAAGC,UAPlCR,EAAAE,KAAA,EAAA,MAAA,KAAA,EAAA,OAAAF,EAAAE,KAAA,EAAAJ,mBAAAW,MAIFvB,KAAAwB,QAAA,CAAAC,MAAApB,EAAAY,KAAAQ,SAJE,KAAA,EAAA,OAAAX,EAAAY,MAaLpB,EAAIa,OAAO,KAAKC,KAAK,wBAbhBN,EAAAE,KAAA,EAAAJ,mBAAAW,MAIFrB,OAAAyB,QAAA,KAJE,KAAA,EAAA,OAIFlB,EAJEK,EAAAY,KAAAZ,EAAAE,KAAA,GAAAJ,mBAAAW,MAKrBrB,OAAA0B,KAAAvB,EAAAY,KAAAY,SAAApB,IALqB,KAAA,GAAA,OAKrBC,EALqBI,EAAAY,KAIFf,EAAA,IAAAX,KAAA,CAAA8B,KAAAzB,EAAAY,KAAAa,KAqBjBL,MAAOpB,EAAIY,KAAKQ,MArBCI,SAAAnB,IAJEI,EAAAC,KAAA,GAAAD,EAAAE,KAAA,GAAAJ,mBAAAW,MAIFZ,EAAAoB,QAJE,KAAA,GAAAjB,EAAAY,KAAAZ,EAAAE,KAAA,GAAA,MAAA,KAAA,GAAAF,EAAAC,KAAA,GAAAD,EAAAkB,GAAAlB,EAAA,MAAA,IAiCnBR,EAAIa,OAAO,KAAKC,KAAhBN,EAAAkB,IAjCmB,KAAA,GAAA,IAAA,MAAA,OAAAlB,EAAAmB,SAAA,KAAA,KAAA,CAAA,CAAA,GAAA,OAIFC,UAAA,SAAA7B,EAAAC,GAAA,IAAA6B,EAAA3B,EAAAG,EAAAyB,EAAA,OAAAxB,mBAAAC,MAAA,SAAAwB,GAAA,OAAA,OAAAA,EAAAtB,KAAAsB,EAAArB,MAAA,KAAA,EAAA,GAAAmB,EAAA/B,gBAAAC,EAAAY,MAAAT,EAAA2B,EAAA3B,MAAA,OAAA6B,EAAAnB,OAAA,SAoCDZ,EAAIa,OAAO,KAAKC,KAAKZ,EAAMa,QAAQ,GAAGC,UApCrCe,EAAArB,KAAA,EAAA,MAAA,KAAA,EAAA,OAAAqB,EAAArB,KAAA,EAAAJ,mBAAAW,MAAAvB,KAAAwB,QAAA,CAAAC,MAAApB,EAAAY,KAAAQ,SAAA,KAAA,EAAA,GAAAd,EAAA0B,EAAAX,KAAA,CAAAW,EAAArB,KAAA,EAAA,MAAA,OAAAqB,EAAAnB,OAAA,SAAAZ,EAAAa,OAAA,KAAAC,KAAA,uBAAA,KAAA,EAAA,OAAAiB,EAAArB,KAAA,GAAAJ,mBAAAW,MAAArB,OAAAoC,QAAAjC,EAAAY,KAAAY,SAAAlB,EAAAkB,WAAA,KAAA,GAAA,GAAAQ,EAAAX,KAAA,CAAAW,EAAArB,KAAA,GAAA,MAAA,OAAAqB,EAAAnB,OAAA,SAkBnBZ,EAAAa,OAAA,KAAAC,KAAA,iBAlBmB,KAAA,GAsBjBS,EAAAA,IAAQU,KAAE7B,CAAAA,IAAAA,EAAAA,KAAAA,QAAAA,IAAAA,cAHUJ,EAAAkC,OAnBH,gBAAAJ,GAAAhB,KAAA,CAAAgB,MAAAA,IAAA,KAAA,GAAA,IAAA,MAAA,OAAAC,EAAAJ,WAAAQ,OAAAC,QAAA,CAAAC,aAAAA,aAAAT,UAAAA","file":"authPost.min.js","sourcesContent":["\nconst User = require('../models/auth')\nconst jwt = require('jsonwebtoken') //for login verification\nconst bcrypt = require('bcryptjs') //we use this to protect the password \nconst {registerValidation, loginValidation} = require('../validation')\n\n\nconst registerPost = async (req,res)=>{\n  //Validate data before we add a user \n  const {error} = registerValidation(req.body)\n  if(error) return res.status(400).send(error.details[0].message)\n\n\n\n  //check if user is in database\n  const emailExist = await User.findOne({email: req.body.email})\n  if (emailExist) res.status(400).send('Email already exists')\n\n\n  //Hash the password - We must protect password from being visible when we save it\n  const salt = await bcrypt.genSalt(10) //the complexity of the string that will get generated to protect our password\n  const hashedPassword = await bcrypt.hash(req.body.password, salt)\n\n\n\n  // To Create a new user\n  const user = new User({\n    name: req.body.name,\n    email: req.body.email,\n    password: hashedPassword\n  });\n\n  try {\n    const savedUser = await user.save()\n    \n  } catch(err) {\n    res.status(400).send(err)\n  }\n}\n\n\nconst loginPost = async (req,res)=>{\n   const {error} = loginValidation(req.body)\n   if(error) return res.status(400).send(error.details[0].message)\n\n   //CHECK IF USER EXISTS\n   const user = await User.findOne({email: req.body.email})\n   if(!user) return res.status(400).send(\"Email is not found\")\n\n   //CHECK IF PASSWORD IS CORRECT\n   const validPass = await bcrypt.compare(req.body.password, user.password) \n   if(!validPass) return res.status(400).send('Login failed')\n   \n  //Create and assign a token\n  //it takes the ID to know the user is logged in and a secret token\n  const token = jwt.sign({_id: user._id}, process.env.TOKEN_SECRET); \n  res.header('Authorization', token).send({token})\n\n}\n\n\nmodule.exports = {registerPost, loginPost}"]}